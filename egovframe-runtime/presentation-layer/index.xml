<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>화면처리 on 표준프레임워크 개발가이드</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/</link><description>Recent content in 화면처리 on 표준프레임워크 개발가이드</description><generator>Hugo</generator><language>ko</language><atom:link href="https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/index.xml" rel="self" type="application/rss+xml"/><item><title>MVC 패턴의 구조와 장점</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet/</guid><description>&lt;h1 id="web-servlet">Web Servlet&lt;/h1>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>&lt;img alt="MVC(Model-View-Controller) 패턴" src="images/web-servlet.jpg">&lt;/p>
&lt;p>&lt;strong>MVC(Model-View-Controller) 패턴&lt;/strong>은 코드를 기능(역할)에 따라 &lt;strong>Model, View, Controller&lt;/strong> 3가지 요소로 분리한다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Model&lt;/strong> : 애플리케이션의 데이터와 비즈니스 로직을 담는 객체이다.&lt;/li>
&lt;li>&lt;strong>View&lt;/strong> : Model의 정보를 사용자에게 표시한다. 하나의 Model을 다양한 View에서 사용할 수 있다.&lt;/li>
&lt;li>&lt;strong>Controller&lt;/strong> : Model과 View의 중계 역할을 한다. 사용자의 요청을 받아 Model에 변경된 상태를 반영하고, 응답을 위한 View를 선택한다.&lt;/li>
&lt;/ul>
&lt;p>MVC 패턴은 &lt;strong>UI 코드와 비즈니스 코드를 분리&lt;/strong>함으로써 &lt;u>종속성을 줄이고, 재사용성을 높이고, 보다 쉬운 변경이 가능&lt;/u>하도록 한다.&lt;/p></description></item><item><title>Spring MVC Architecture</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-spring-mvc-architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-spring-mvc-architecture/</guid><description>&lt;h1 id="spring-mvc-architecture">Spring MVC Architecture&lt;/h1>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>Spring Framework은 간단한 설정만으로 Struts나 Webwork같은 Web Framework을 사용할 수 있지만, 자체적으로 MVC Web Framework을 가지고 있다.
Spring MVC는 기본요소인 Model, View, Controller 외에도, 아래와 같은 특성을 가지고 있다.&lt;/p>
&lt;ul>
&lt;li>DispatcherServlet, HandlerMapping, Controller, Interceptor, ViewResolver, View등 각 컴포넌트들의 역할이 명확하게 분리되어 있다.&lt;/li>
&lt;li>HandlerMapping, Controller, View등 컴포넌트들에 다양한 인터페이스 및 구현 클래스를 제공함으로써 경우에 따라 선택하여 사용할 수 있다.&lt;/li>
&lt;li>Controller(@MVC)나 폼 클래스(커맨드 클래스) 작성시에 특정 클래스를 상속받거나 참조할 필요 없이 POJO 나 POJO-style의 클래스를 작성함으로써 비지니스 로직에 집중한 코드를 작성할 수 있다.&lt;/li>
&lt;li>웹요청 파라미터와 커맨드 클래스간에 데이터 매핑 기능을 제공한다.&lt;/li>
&lt;li>데이터 검증을 할 수 있는, Validator와 Error 처리 기능을 제공한다.&lt;/li>
&lt;li>JSP Form을 쉽게 구성하도록 Tag를 제공한다.&lt;/li>
&lt;/ul>
&lt;h2 id="설명">설명&lt;/h2>
&lt;p>Spring MVC(Model-View-Controller)의 핵심 Component는 아래와 같다.&lt;/p></description></item><item><title>DispatcherServlet</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-dispatcherservlet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-dispatcherservlet/</guid><description>&lt;h1 id="dispatcherservlet">DispatcherServlet&lt;/h1>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>Spring MVC Framework의 유일한 Front Controller인 DispatcherServlet은 Spring MVC의 핵심 요소이다.
DispatcherServlet은 Controller로 향하는 모든 웹요청의 진입점이며, 웹요청을 처리하며, 결과 데이터를 Client에게 응답 한다.
DispatcherServlet은 Spring MVC의 웹요청 Life Cycle을 주관한다 할 수 있다.&lt;/p>
&lt;h2 id="설명">설명&lt;/h2>
&lt;h3 id="dispatcherservlet에서의-웹요청-흐름">DispatcherServlet에서의 웹요청 흐름&lt;/h3>
&lt;p>Client의 웹요청시에 DispatcherServlet에서 이루어지는 처리 흐름은 아래와 같다.
좀더 자세한 처리 흐름을 알고 싶다면 디버깅모드로 과정을 추적해 보는 것을 권장한다.&lt;/p>
&lt;p>&lt;img alt="DispatcherServlet flow" src="../images/web-servlet-dispatcherservlet-flow.png">&lt;/p>
&lt;ol>
&lt;li>doService 메소드에서부터 웹요청의 처리가 시작된다. DispatcherServlet에서 사용되는 몇몇 정보를 request 객체에 담는 작업을 한 후 doDispatch 메소드를 호출한다.&lt;/li>
&lt;li>아래 3번~13번 작업이 doDispatch 메소드안에 있다. Controller, View 등의 컴포넌트들을 이용한 실제적인 웹요청처리가 이루어 진다.&lt;/li>
&lt;li>getHandler 메소드는 RequestMapping 객체를 이용해서 요청에 해당하는 Controller를 얻게 된다.&lt;/li>
&lt;li>요청에 해당하는 Handler를 찾았다면 Handler를 HandlerExecutionChain 객체에 담아 리턴하는데, 이때 HandlerExecutionChain는 요청에 해당하는 interceptor들이 있다면 함께 담아 리턴한다.&lt;/li>
&lt;li>실행될 interceptor들이 있다면 interceptor의 preHandle 메소드를 차례로 실행한다.&lt;/li>
&lt;li>Controller의 인스턴스는 HandlerExecutionChain의 getHandler 메소드를 이용해서 얻는다.&lt;/li>
&lt;li>HandlerMapping과 마찬가지로 여러개의 HanlderAdaptor를 설정할 수 있는데, getHandlerAdaptor 메소드는 Controller에 적절한 HanlderAdaptor 하나를 리턴한다.&lt;/li>
&lt;li>선택된 HanlderAdaptor의 handle 메소드가 실행되는데, 실제 실행은 파라미터로 넘겨 받은 Controller를 실행한다.&lt;/li>
&lt;li>계층형 Controller인 경우는 handleRequest 메소드가 실행된다. @Controller인 경우는 HanlderAdaptor(AnnotationMethodHandlerAdapter)가 HandlerMethodInvoker를 이용해 실행할 Controller의 메소드를 invoke()한다.&lt;/li>
&lt;li>interceptor의 postHandle 메소드가 실행된다.&lt;/li>
&lt;li>resolveViewName 메소드는 논리적 뷰 이름을 가지고 해당 View 객체를 반환한다.&lt;/li>
&lt;li>Model 객체의 데이터를 보여주기 위해 해당 View 객체의 render 메소드가 수행된다.&lt;/li>
&lt;/ol>
&lt;h3 id="webxml에-dispatcherservlet-설정하기">web.xml에 DispatcherServlet 설정하기&lt;/h3>
&lt;p>Spring MVC Framework을 사용하기 위해서는 web.xml에 DispatcherServlet을 설정하고, DispatcherServlet이 WebApplicationContext를 생성할수 있도록 빈(Bean) 정보가 있는 파일들도 설정해주어야 한다.&lt;/p></description></item><item><title>HandlerMapping</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-handlermapping/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-handlermapping/</guid><description>&lt;h1 id="handlermapping">HandlerMapping&lt;/h1>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>DispatcherServlet에 Client로부터 Http Request가 들어 오면 HandlerMapping은 요청처리를 담당할 Controller를 mapping한다.
Spring MVC는 interface인 HandlerMapping의 구현 클래스도 가지고 있는데, 용도에 따라 여러 개의 HandlerMapping을 사용하는 것도 가능하다.
빈 정의 파일에 HandlerMapping에 대한 정의가 없다면 Spring MVC는 기본(default) HandlerMapping을 사용한다.&lt;/p>
&lt;p>기본 HandlerMapping은 BeanNameUrlHandlerMapping이며, jdk1.5 이상의 실행환경일 때, Spring 3.1이후 버전이면(egov 3.0부터) RequestMappingHandlerMapping가 기본 HandlerMapping이며,
Spring 3.1이전 버전이면(egov 3.0이전 버전) DefaultAnnotationHandlerMapping가 기본 HandlerMapping이다.
(DefaultAnnotationHAndlerMapping은 3.1부터 deprecated되고 RequestMappingHandlerMapping으로 대체됨)&lt;/p>
&lt;h2 id="설명">설명&lt;/h2>
&lt;p>BeanNameUrlHandlerMapping, SimpleUrlHandlerMapping 등 주요 HandlerMapping 구현 클래스는 상위 추상 클래스인 AbstractHandlerMapping과 AbstractUrlHandlerMapping을 확장하기 때문에 이 추상클래스들의 프로퍼티를 사용한다.
주요 프로퍼티는 아래와 같다.&lt;/p></description></item><item><title>Spring MVC Tag Configuration</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-spring-mvc-tag-configuration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-spring-mvc-tag-configuration/</guid><description>&lt;h1 id="spring-mvc-tag-configuration">Spring MVC Tag Configuration&lt;/h1>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>Spring 3부터 mvc태그를 통하여 Controller처리를 위한 설정을 쉽게 하도록 Spring mvc 네임스페이스를 제공한다.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://eGovFramework.github.io/egovframe-docs/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-spring-mvc-tag-configuration/#mvcannotation-driven">&lt;a href="mvc:annotation-driven">mvc:annotation-driven&lt;/a>&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://eGovFramework.github.io/egovframe-docs/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-spring-mvc-tag-configuration/#mvcinterceptors">&lt;a href="mvc:interceptors">mvc:interceptors&lt;/a>&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://eGovFramework.github.io/egovframe-docs/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-spring-mvc-tag-configuration/#mvcview-controller">&lt;a href="mvc:view-controller">mvc:view-controller&lt;/a>&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="설명">설명&lt;/h2>
&lt;h3 id="mvcannotation-driven">mvc:annotation-driven&lt;/h3>
&lt;p>Spring 3.0부터 제공하는 mvc 태그 설정이다. Annotation기반의 Controller호출 설정과 필요한 bean설정을 편리하게 하도록 만들어졌다. 그러나 내부 수정이 어렵기 때문에 mvc:annotation-driven에서 제공하는 기능에 대하여 잘 숙지하고 변경이 불가능 한 경우에는 mvc:annotation-driven을 쓰지 않고 필요한 bean을 수동으로 넣어줘야하는 경우도 있다.
mvc:annotation-driven에서 쓰는 bean설정을 중복으로 쓰지 않도록 주의한다.&lt;/p>
&lt;h4 id="mvcannotation-driven에서-제공하는-기능">mvc:annotation-driven에서 제공하는 기능&lt;/h4>
&lt;ul>
&lt;li>RequestMappingHandlerMapping bean등록(기존 DefaultAnnotationHandlerMapping)&lt;/li>
&lt;li>RequestMappingHandlerAdapter bean등록(기존 AnnotationMethodHandlerAdapter)
&lt;ul>
&lt;li>customArgumentResolvers, customReturnValueHandlers 추가 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>JSR-303의 검증용 어노테이션(@Valid)를 사용할 수 있도록 LocalValidatorFactoryBean bean설정 (JSR-303지원 라이브러리 존재 시)&lt;/li>
&lt;li>RequestMappingHandlerAdapter의 messageConverters프로퍼티로 메시지 컨버터들 등록&lt;/li>
&lt;/ul>
&lt;p>(다음 설정과 동일한 동작을 한다.)&lt;/p></description></item><item><title>Controller</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-controller/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-controller/</guid><description>&lt;h1 id="controller">Controller&lt;/h1>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>DispatcherServlet은 HandlerMapping를 이용해서 해당 요청을 처리할 Controller를 결정한다.
이 Controller는 요청에 대해서 처리를 하고 데이터를 Model 객체에 반영한다.
Spring MVC는 다양한 종류의 Controller를 제공하는데, 데이터 바인딩이나 폼 처리 또는 멀티 액션등의 편의 기능을 제공한다.
이 Controller들은 org.springframework.web.servlet.mvc.Controller 인터페이스를 구현한 클래스들이다.(@Controller는 예외다. 여기서는 @Controller에 대한 설명은 제외한다.)
eclipse에서 인터페이스 Controller를 Hierarchy View에서 열어보면 아래와 같은 구조를 보여준다.&lt;/p>
&lt;p>&lt;img alt="Controller preview" src="../images/web-servlet-controller-preview.png">&lt;/p>
&lt;p>이 중 주요 Controller의 용도 및 특징을 표로 나타내면 아래와 같다.&lt;/p></description></item><item><title>Annotation 기반 Controller</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-annotation-based-controller/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-annotation-based-controller/</guid><description>&lt;h1 id="annotation-based-controller">Annotation-based Controller&lt;/h1>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>스프링 프레임워크는 2.5 버젼 부터 Java 5+ 이상이면 @Controller(Annotation-based Controller)를 개발할 수 있는 환경을 제공한다.
인터페이스 Controller를 구현한 SimpleFormController, MultiActionController 같은 기존의 계층형(Hierarchy) Controller와의 주요 차이점 및 개선점은 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://eGovFramework.github.io/egovframe-docs/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-annotation-based-controller/#어노테이션을-이용한-설정">어노테이션을 이용한 설정&lt;/a>
&lt;ul>
&lt;li>XML 기반으로 설정하던 정보들을 어노테이션을 사용해서 정의한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://eGovFramework.github.io/egovframe-docs/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-annotation-based-controller/#유연해진-메소드-시그니쳐">유연해진 메소드 시그니쳐&lt;/a>
&lt;ul>
&lt;li>Controller 메소드의 파라미터와 리턴 타입을 좀 더 다양하게 필요에 따라 선택할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://eGovFramework.github.io/egovframe-docs/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-annotation-based-controller/#pojo-style의-controller">POJO-Style의 Controller&lt;/a>
&lt;ul>
&lt;li>Controller 개발시에 특정 인터페이스를 구현 하거나 특정 클래스를 상속해야할 필요가 없다.&lt;/li>
&lt;li>하지만 폼 처리, 다중 액션등 기존의 계층형 Controller가 제공하던 기능들을 여전히 쉽게 구현할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>계층형 Controller로 작성된 폼 처리를 @Controller로 구현하는 예도 설명한다.
예제 코드 easycompany의 Controller는 동일한 기능(또한 공통의 Service, DAO, JSP를 사용)을 계층형 Controller와 @Controller로 각각 작성했다.&lt;/p></description></item><item><title>Spring의 Validator 인터페이스와 유효성 검증</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-validation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-validation/</guid><description>&lt;h1 id="validation">Validation&lt;/h1>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>객체의 유효성 검증을 위해 스프링 프레임워크는 org.springframework.validation.Validator라는 인터페이스를 제공한다.
Validator는 특정 계층에 종속적인 구조가 아니라서, web이나 data-access등 어떤 계층의 객체라도 유효성 검증이 가능하게 한다.
Jakarta Commons Validator나 Valang 같은 외부 Validator들도 Spring 프레임워크에서 사용할 수 있다.
Spring Modules를 이용한 Jakarta Commons Validator 사용 방법에 대해서는 Spring Framework에서 Commons Validator 사용 을 참고하라.&lt;/p>
&lt;h2 id="설명">설명&lt;/h2>
&lt;p>부서 정보를 수정하는 페이지에서 커맨드 객체인 부서 정보 클래스를 유효성 검증하는 코드를 작성해 보자.
부서 클래스인 Department 클래스는 아래와 같다.&lt;/p></description></item><item><title>Bean Validation (JSR-303)</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-declarative-validation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-declarative-validation/</guid><description>&lt;h1 id="bean-validation-jsr-303">Bean Validation (JSR-303)&lt;/h1>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>&lt;a href="https://eGovFramework.github.io/egovframe-docs/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-validation/">화면처리: validation&lt;/a>을 통해 검증방법을 알아보았다. 이전과는 다르게 JSR-303(Bean Validation) 스펙은 자동 검증 방식을 제공한다. @javax.validation.Valid애노테이션을 사용하여 내부적으로(자동으로) 검증이 수행된다.&lt;/p>
&lt;p>또한, 최근에 표준 스펙으로 인증받은 JSR-303 빈 검증방식을 이용하여 모델 오브젝트 필드에서 애노테이션을 이용해 검증을 진행할 수 있다.&lt;/p>
&lt;h2 id="설명">설명&lt;/h2>
&lt;h3 id="valid를-이용한-자동검증">@Valid를 이용한 자동검증&lt;/h3>
&lt;p>기존의 검증 방식을 자동 검증 방식으로 변경하였으며, 방법은 컨트롤러 메소드의 &lt;code>@ModelAttribute&lt;/code> 파라미터에 &lt;code>@Valid&lt;/code> 애노테이션을 추가한다. 그러면 &lt;code>validate()&lt;/code> 메소드를 실행하는 대신 바인딩 과정에서 자동으로 검증이 진행된다.&lt;/p></description></item><item><title>View</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-view/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-view/</guid><description>&lt;h1 id="view">View&lt;/h1>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>Controller가 요청에 대한 처리를 하고, View 이름과 데이터(Model)를 ModelAndView에 저장해 DispatcherServlet에 반환(return)하면,
DispatcherServlet은 View 이름을 가지고 ViewResolver에게서 실제 View 객체를 얻고, 이 View는 Controller가 저장한 Model 객체의 정보를 출력한다.
여기서는 View와 ViewResolver, 그리고 JSP에서 편리한 데이터 출력을 위해 스프링이 제공하는 Spring form tag library에 대해서 설명한다.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://eGovFramework.github.io/egovframe-docs/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-view/#view">View&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://eGovFramework.github.io/egovframe-docs/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-view/#개요">개요&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://eGovFramework.github.io/egovframe-docs/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-view/#설명">설명&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://eGovFramework.github.io/egovframe-docs/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-view/#viewresolver">ViewResolver&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://eGovFramework.github.io/egovframe-docs/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-view/#internalresourceviewresolverurlbasedviewresolver">InternalResourceViewResolver/UrlBasedViewResolver&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://eGovFramework.github.io/egovframe-docs/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-view/#view-1">View&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://eGovFramework.github.io/egovframe-docs/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-view/#spring-tag-library">Spring Tag Library&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://eGovFramework.github.io/egovframe-docs/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-view/#meassage-tagspringmessage">meassage tag(&lt;code>&amp;lt;spring:message&amp;gt;&lt;/code>)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://eGovFramework.github.io/egovframe-docs/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-view/#form-tagformformforminput">form tag(&lt;code>&amp;lt;form:form&amp;gt;,&amp;lt;form:input&amp;gt;,...&lt;/code>)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://eGovFramework.github.io/egovframe-docs/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-view/#전자정부프레임워크-tag-library">전자정부프레임워크 Tag Library&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://eGovFramework.github.io/egovframe-docs/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-view/#참고자료">참고자료&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="설명">설명&lt;/h2>
&lt;h3 id="viewresolver">ViewResolver&lt;/h3>
&lt;p>Controller는 코드내에서 실제 View 객체를 생성하지 않고 View 이름만을 결정할 수 있는데, 이로써 Controller와 View의 분리(decoupling)를 가능하게 한다.&lt;/p></description></item><item><title>Map 객체를 통한 입력값 처리 방법</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-annotationcommandmapargumentresolver/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-servlet-annotationcommandmapargumentresolver/</guid><description>&lt;h1 id="annotationcommandmapargumentresolver">AnnotationCommandmapArgumentResolver&lt;/h1>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>Controller에서 화면(JSP) 입력값을 받기 위해서 일반적으로 Command(Form Class) 객체를 사용하지만, Map 객체를 사용하는걸 선호할 수 있다.
전자정부프레임워크 버전 3.0이전에서는 CommandMapArgumentResolver를 통해 Map객체를 사용할 수 있었다. 그러나 3.0부터는 @CommandMap과 AnnotationCommandmapArgumentResolver를 통해 Map객체를 사용할 수 있다.
org.springframework.web.method.support.HandlerMethodArgumentResolver의 구현클래스인 AnnotationCommandMapArgumentResolver은 HTTP request 객체에 있는 파라미터이름과 값을 Map 객체에 담아 Controller에서 사용도록 제공한다.&lt;/p>
&lt;h2 id="설명">설명&lt;/h2>
&lt;h3 id="handlermethodargumentresolver">HandlerMethodArgumentResolver&lt;/h3>
&lt;p>Sping MVC의 &lt;code>@Controller&lt;/code>의 메소드의 argument로 사용할 수 있는 유형(이에 관한 정보는 이곳을 참조하라.)은 기존의 계층형 Controller보다 다양해 졌지만,
필요에 따라 기본 유형외의 custom argument를 사용해야 할때가 있을 것이다.
Sping MVC는 Controller의 argument 유형을 customizing 할 수 있는 HandlerMethodArgumentResolver라는 interface를 제공한다.
기존 Spring web 3.1이전 버전에서는 WebArgumentResolver를 구현하여 AnnotationMethodHandlerAdapter에 등록하여 ArgumentResolver를 적용하였으나,
3.1이후부터는 HandlerMethodArgumentResolver를 구현하여 RequestMappingHandlerAdapter에 등록하여 ArgumentResolver를 적용해야 한다.&lt;/p></description></item><item><title>스프링 WebFlux와 기존 스프링 웹 프레임워크 비교</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-reactive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-reactive/</guid><description>&lt;h1 id="web-reactive">Web Reactive&lt;/h1>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>스프링 프레임워크, 스프링 웹 MVC를 포함한 기존 웹 프레임워크는 서블릿 API와 서블릿 컨테이너를 위해 개발되었다. 스프링 WebFlux는 5.0 버전부터 추가된 리액티브 스택 웹 프레임워크로서, 서블릿 API와 서블릿 컨테이너를 개발하기 위한 스프링 프레임워크이다.
스프링 웹 MVC를 포함한 기존의 웹 프레임워크와 달리 완전한 논블로킹으로 동작하며 Reactive Streams back pressure를 지원하고 Netty, Undertow, 서블릿 3.1+ 컨테이너 서버에서 실행된다. 웹 프레임워크 모두 스프링 프레임워크에 포함되어 있으며, 원하는 모듈을 선택하여 개발할 수 있다.&lt;/p></description></item><item><title>Reactive Core</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-reactive-reactive-core/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-reactive-reactive-core/</guid><description>&lt;h1 id="reactive-core">Reactive Core&lt;/h1>
&lt;h2 id="설명">설명&lt;/h2>
&lt;p>스프링-웹 모듈에는 반응형 웹 애플리케이션을 위한 다음과 같은 기본 지원이 포함되어 있다.&lt;/p>
&lt;ul>
&lt;li>서버 요청 처리에는 두 가지 수준을 지원한다.
&lt;ul>
&lt;li>HttpHandler: 논블로킹 I/O 및 리액티브 스트림 Back Pressure을 사용하는 HTTP 요청을 처리하며, Reactor Netty, Undertow, Tomcat, Jetty 및 모든 Servlet 3.1+ 컨테이너용 어댑터와 함께 사용한다.&lt;/li>
&lt;li>WebHandler API: 요청 처리를 위한 약간 더 높은 수준의 범용 웹 API로, 주석이 달린 컨트롤러 및 기능적 엔드포인트와 같은 구체적인 프로그래밍 모델로 작성되어 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>클라이언트 사이드에서는 논블로킹 I/O 및 리액티브 스트림 Back Pressure으로 HTTP 요청을 수행하는 기본 ClientHttpConnector 계약과 함께 Reactor Netty, 리액티브 Jetty HttpClient 및 Apache HttpComponents용 어댑터가 있다. 애플리케이션에 사용되는 상위 수준의 WebClient는 이를 기반으로 구축된다.&lt;/li>
&lt;li>클라이언트와 서버 모두 코덱으로 HTTP 요청 및 응답 콘텐츠의 직렬화 및 역직렬화를 한다.&lt;/li>
&lt;/ul>
&lt;h3 id="httphandler">HttpHandler&lt;/h3>
&lt;p>HttpHandler는 요청과 응답을 처리하는 메소드를 하나만 가지고 있다. 의도적으로 최소한의 기능을 제공하며, 주된 목적은 다양한 HTTP 서버 API에 대한 최소한의 추상화이다.
지원하는 서버의 API는 아래 표와 같다.&lt;/p></description></item><item><title>스프링 WebFlux의 DispatcherHandler와 요청 처리 흐름</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-reactive-dispatcherhandler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-reactive-dispatcherhandler/</guid><description>&lt;h1 id="dispatcherhandler">DispatcherHandler&lt;/h1>
&lt;h2 id="설명">설명&lt;/h2>
&lt;p>스프링 WebFlux도 스프링 MVC와 유사한 프론트 컨트롤러 패턴을 사용한다. 중앙 WebHandler가 받은 요청을 다른 컴포넌트에 위임하는데 DispatcherHandler가 바로 이 중앙 WebHandler다. 이 모델 덕분에 다양한 워크플로우를 지원할 수 있다.
DispatcherHandler는 스프링 설정에 따라 그에 맞는 컴포넌트로 위임한다. DispatcherHandler도 스프링 빈이며 ApplicationContextAware 인터페이스를 구현했기 때문에 실행중인 컨텍스트에 접근할 수 있다. DispatcherHandler 빈을 WebHandler 이름으로 정의하면 WebHttpHandlerBuilder가 감지하고 WebHandler API에서 설명했던 체인에 추가한다.&lt;/p>
&lt;p>WebFlux 애플리케이션에서 사용하는 일반적인 스프링 설정은 다음과 같다.&lt;/p></description></item><item><title>스프링 WebFlux에서 어노테이션 기반 컨트롤러 활용 방법</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-reactive-annotated-controllers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-reactive-annotated-controllers/</guid><description>&lt;h1 id="annotated-controllers">Annotated Controllers&lt;/h1>
&lt;h2 id="설명">설명&lt;/h2>
&lt;p>스프링 WebFlux는 어노테이션 기반 프로그램밍 모델을 지원하기 때문에 @Controller, @RestController 컴포넌트로 요청을 매핑하고, 입력을 받고, 예외처리를 할수 있다. 컨트롤러는 메소드를 여러가지로 활용할 수 있어서 클래스를 상속하거나 인터페이스를 구현하지 않아도 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5c35cc;font-weight:bold">@RestController&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">public&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">class&lt;/span> &lt;span style="color:#000">HelloController&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#5c35cc;font-weight:bold">@GetMapping&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;/hello&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">public&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">String&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">handle&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">return&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#4e9a06">&amp;#34;Hello WebFlux&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위 코드에서는 response body에 쓸 String을 리턴한다.&lt;/p>
&lt;h3 id="controller">@Controller&lt;/h3>
&lt;p>컨트롤러는 표준 스프링 빈으로 정의한다. @Controller 어노테이션을 달면 스프링이 클래스패스 내의 다른 @Component 클래스처럼 자동으로 스캔하고 빈으로 등록한다. 이 어노테이션을 선언하면 그 클래스가 Web 컴포넌트라는 뜻이기도 하다.
@Controller 빈을 자동으로 등록하려면 아래와 같이 컴포넌트 스캔을 위한 설정이 필요하다.&lt;/p></description></item><item><title>스프링 WebFlux 함수형 프로그래밍 모델(WebFlux.fn)</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-reactive-functional-endpoints/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-reactive-functional-endpoints/</guid><description>&lt;h1 id="functional-endpoints">Functional Endpoints&lt;/h1>
&lt;p>스프링 WebFlux는 경량화 된 함수형 프로그래밍 모델을 지원한다. WebFlux.fn이라고 하는 이 모델은 함수로 요청을 라우팅하고 핸들링하기 때문에 불변성(immutability)을 보장한다.
함수형 모델과 어노테이션 모델 중 하나를 선택하면 되는데 둘 다 리액티브 코어를 기반으로 한다.&lt;/p>
&lt;h2 id="설명">설명&lt;/h2>
&lt;p>WebFlux.fn에선 HandlerFunction이 HTTP 요청을 처리한다. HandlerFunction은 ServerRequest를 받아 비동기 ServerResponse(예를 들어 Mono&lt;ServerResponse>)를 리턴하는 함수다. 요청, 응답 객체 모두 불변하기 때문에 JDK 8 방식으로 HTTP 요청, 응답에 접근할 수 있다. HandlerFunction 역할은 어노테이션 프로그래밍 모델로 치면 @RequestMapping 메소드와 동일하다.&lt;/p></description></item><item><title>스프링 WebFlux의 WebClient와 논블로킹 처리</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-reactive-webclient/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/web-reactive-webclient/</guid><description>&lt;h1 id="webclient">WebClient&lt;/h1>
&lt;p>스프링 WebFlux는 리액티브, 논블로킹 HTTP 요청을 위한 WebClient를 제공한다. 웹 클라이언트는 리액티브 타입을 사용하는 함수형 API이기 때문에 선언적인(declarative) 프로그래밍이 가능하다. 웹플럭스 클라이언트와 서버는 동일한 논블로킹 코덱으로 요청, 응답을 인코딩, 디코딩한다.&lt;/p>
&lt;h2 id="설명">설명&lt;/h2>
&lt;p>WebClient는 요청을 수행하기 위해 HTTP 클라이언트 라이브러리에 처리를 위임하며 아래와 같은 기능을 기본으로 제공한다.&lt;/p>
&lt;ul>
&lt;li>Reactor Netty&lt;/li>
&lt;li>Jetty Reactive HttpClient&lt;/li>
&lt;li>Apache HttpComponents&lt;/li>
&lt;li>Others can be plugged via ClientHttpConnector.&lt;/li>
&lt;/ul>
&lt;h3 id="configuration">Configuration&lt;/h3>
&lt;p>WebClient는 가장 간단하게는 스태틱 팩토리 메소드로 만들 수 있다.&lt;/p>
&lt;ul>
&lt;li>WebClient.create()&lt;/li>
&lt;li>WebClient.create(String baseUrl)&lt;/li>
&lt;/ul>
&lt;p>위 메소드는 디폴트 세팅으로 Reactor Netty HttpClient를 사용하므로 클래스패스에 io.projectreactor.netty:reactor-netty가 있어야 한다.&lt;/p></description></item><item><title>Ajax 지원 서비스</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/ajax/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/ajax/</guid><description>&lt;h1 id="ajax-지원-서비스">Ajax 지원 서비스&lt;/h1>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>일반적으로 Ajax 기능은 javascript 언어로 개발하나, server-side 구현에 익숙한 J2EE 개발자들에게는 쉽지 않은 작업이 될 수 있다.
Ajax 지원 서비스에서는 Ajax를 이용해 자주 사용되는 기능을 custom tag형태로 제공한다.
기능은 오픈소스 라이브러리인 AjaxTags를 이용한다.&lt;/p>
&lt;h2 id="설명">설명&lt;/h2>
&lt;h3 id="설치">설치&lt;/h3>
&lt;p>&lt;strong>시스템 환경 및 필요 라이브러리&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>JDK 1.5&lt;/li>
&lt;li>Servlet container running Servlets 2.4+ and JSP 2.0+ (jsp-api 2.0,servlet-api 2.4)&lt;/li>
&lt;li>&lt;a href="http://ajaxtags.sourceforge.net/">AjaxTags 라이브러리&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>설치 순서&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;a href="http://sourceforge.net/project/showfiles.php?group_id=140499">AjaxTags Download&lt;/a> 사이트에 가서 해당 라이브러리를 download한 후 WEB-INF/lib에 위치시킨다.&lt;/li>
&lt;li>web.xml 설정.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">&amp;lt;servlet&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;lt;servlet-name&amp;gt;&lt;/span>sourceloader&lt;span style="color:#204a87;font-weight:bold">&amp;lt;/servlet-name&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;lt;servlet-class&amp;gt;&lt;/span>net.sourceforge.ajaxtags.servlets.SourceLoader&lt;span style="color:#204a87;font-weight:bold">&amp;lt;/servlet-class&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;lt;init-param&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;lt;param-name&amp;gt;&lt;/span>prefix&lt;span style="color:#204a87;font-weight:bold">&amp;lt;/param-name&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;lt;param-value&amp;gt;&lt;/span>/ajaxtags&lt;span style="color:#204a87;font-weight:bold">&amp;lt;/param-value&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;lt;/init-param&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">&amp;lt;/servlet&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">&amp;lt;servlet-mapping&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;lt;servlet-name&amp;gt;&lt;/span>sourceloader&lt;span style="color:#204a87;font-weight:bold">&amp;lt;/servlet-name&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;lt;url-pattern&amp;gt;&lt;/span>/ajaxtags/js/*&lt;span style="color:#204a87;font-weight:bold">&amp;lt;/url-pattern&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">&amp;lt;/servlet-mapping&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">&amp;lt;servlet-mapping&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;lt;servlet-name&amp;gt;&lt;/span>sourceloader&lt;span style="color:#204a87;font-weight:bold">&amp;lt;/servlet-name&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;lt;url-pattern&amp;gt;&lt;/span>/ajaxtags/img/*&lt;span style="color:#204a87;font-weight:bold">&amp;lt;/url-pattern&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">&amp;lt;/servlet-mapping&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">&amp;lt;servlet-mapping&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;lt;servlet-name&amp;gt;&lt;/span>sourceloader&lt;span style="color:#204a87;font-weight:bold">&amp;lt;/servlet-name&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;lt;url-pattern&amp;gt;&lt;/span>/ajaxtags/css/*&lt;span style="color:#204a87;font-weight:bold">&amp;lt;/url-pattern&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">&amp;lt;/servlet-mapping&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ajaxtags-tag-reference">AjaxTags Tag Reference&lt;/h3>
&lt;p>&lt;strong>ajax:autocomplete&lt;/strong>&lt;/p></description></item><item><title>Internationalization(국제화)</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/internationalization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/internationalization/</guid><description>&lt;h1 id="internationalization국제화">Internationalization(국제화)&lt;/h1>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>전자정부 표준 프레임워크에서는 Spring MVC 에서 제공하는 LocaleResolver를 이용한다.
우리는 여기서 LocaleResolver를 알아보고 적용하는 설정과 다국어가 적용된 message resource 를 가져와 활용하는 것을 보도록 하겠다.
Spring MVC 는 다국어를 지원하기 위하여 아래와 같은 종류의 LocaleResolver 를 제공하고 있다.&lt;/p>
&lt;ul>
&lt;li>CookieLocaleResolver
&lt;ul>
&lt;li>쿠키를 이용한 locale정보 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>SessionLocaleResolver
&lt;ul>
&lt;li>세션을 이용한 locale정보 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>AcceptHeaderLocaleResolver
&lt;ul>
&lt;li>클라이언트의 브라우져에 설정된 locale정보 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Bean 설정 파일에 정의하지 않을 경우 AcceptHeaderLocaleResolver 를 default 로 적용된다.&lt;/strong>&lt;/p>
&lt;h2 id="설명">설명&lt;/h2>
&lt;h3 id="3가지의-localeresolver">3가지의 LocaleResolver&lt;/h3>
&lt;h4 id="cookielocaleresolver">CookieLocaleResolver&lt;/h4>
&lt;p>CookieLocaleResolver 를 설정하는 경우 사용자의 쿠키에 설정된 Locale 을 읽어 들인다.
samlple-servlet.xml&lt;/p></description></item><item><title>Security Service</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/security/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/security/</guid><description>&lt;h1 id="security-service">Security Service&lt;/h1>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>인증, 권한 같은 일반적인(통상적인) 개념의 Security 서비스는 Spring Security를 활용한 공통기반 레이어에서 제공한다.
화면 처리 레이어의 Security 서비스는 입력값 유효성 검증 기능을 제공한다.
입력값 유효성 검증(validation)을 위한 기능은 Valang, Jakarta Commons, Spring 등에서 제공하는데, 여기서는 기반 오픈소스로 Jakarta Commons Validator를 선택했다.
MVC 프레임워크인 Spring MVC와 Jakarta Commons Validator의 연계와 활용방안을 설명한다.&lt;/p>
&lt;h2 id="설명">설명&lt;/h2>
&lt;p>Jakarta Commons Validator는 필수값, 각종 primitive type(int,long,float…), 최대-최소길이, 이메일, 신용카드번호등의 값 체크등을 할 수 있도록 Template이 제공된다.
또한 client-side, server-side의 검증을 함께 할 수 있으며,
Configuration과 에러메시지를 client-side, server-side 별로 따로 하지 않고 한곳에 같이 쓰는 관리상의 장점이 있다.
자세한 설명은 아래의 문서를 참조하라.&lt;/p></description></item><item><title>Spring Framework + Jakarta Commons Validator</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/security-jakarta-commons-validator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/security-jakarta-commons-validator/</guid><description>&lt;h1 id="spring-framework--jakarta-commons-validator">Spring Framework + Jakarta Commons Validator&lt;/h1>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>입력값 검증을 위한 Validation 기능은 Valang, Jakarta Commons, Spring 등에서 제공한다.&lt;br>
여기서는 Jakarta Commons Validator를 Spring Framework과 연동하여 사용하는 방법에 대해서 설명하고자 한다.&lt;br>
Jakarta Commons Validator는 필수값, 각종 primitive type(int,long,float…), 최대-최소길이, 이메일, 신용카드번호등의 값 체크등을 할 수 있도록 Template이 제공된다.&lt;br>
이 Template은 Java 뿐 아니라 Javascript로도 제공되어 client-side, server-side의 검증을 함께 할 수 있으며,
Configuration과 에러메시지를 client-side, server-side 별로 따로 하지 않고 한곳에 같이 쓰는 관리상의 장점이 있다.&lt;br>
Struts에서는 Commons Validator를 사용하기 위한 org.apache.struts.validator.ValidatorPlugIn 같은 플러그인 클래스를 제공하는데,
Spring에서는 Spring Modules 프로젝트에서 연계 모듈을 제공한다.&lt;br>
여기서는 server-side, client-side validation을 위해,
설치방법, Spring Module에서 제공하는 핵심 클래스인 DefaultValidatorFactory, DefaultValidator와 설정파일인 validator-rules.xml, validator.xml 에 대한 간략한 설명과
예제 프로젝트인 easycompany에 적용하는 과정을 설명한다.&lt;/p></description></item><item><title>Commons Validator에 validation rule 추가하기</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/security-validationa-add-rules-in-common-validator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/security-validationa-add-rules-in-common-validator/</guid><description>&lt;h1 id="commons-validator에-validation-rule-추가하기">Commons Validator에 validation rule 추가하기&lt;/h1>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>Commons Validator는 primitive type, 필수값, 이메일등 흔히 사용되는 유형에 대한 validation rule을 template으로 제공하지만,
프로젝트의 특성에 따라 공통으로 사용되는 validation rule이 발생되고 이를 추가해야할 필요가 생길 수 있다.
공공프로젝트에서 흔히 사용되는 주민등록번호 validator를 추가해 봄으로써, validation rule을 추가하는 방법을 알아보고자 한다.&lt;br>
예제는 easycompany를 이용했다.&lt;/p>
&lt;h2 id="설명">설명&lt;/h2>
&lt;p>Spring Module을 이용해서 Commons Validator를 사용한다면 아래와 같은 내용을 validation rule 정의 파일(validator-rules.xml 같은)에서 보았을 것이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">&amp;lt;!--필수값 체크 validation rule--&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;lt;validator&lt;/span> &lt;span style="color:#c4a000">name=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;required&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c4a000">classname=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;org.springmodules.validation.commons.FieldChecks&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c4a000">method=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;validateRequired&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c4a000">methodParams=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;java.lang.Object,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06"> org.apache.commons.validator.ValidatorAction,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06"> org.apache.commons.validator.Field,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06"> org.springframework.validation.Errors&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c4a000">msg=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;errors.required&amp;#34;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;lt;javascript&amp;gt;&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&amp;lt;![CDATA[
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> ]]&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;lt;/javascript&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;lt;/validator&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>validator 태그의 각각의 attribute는 다음과 같은 의미를 같는다.&lt;/p></description></item><item><title>UI Adaptor Service</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/ui-adaptor-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/ui-adaptor-service/</guid><description>&lt;h1 id="ui-adaptor-service">UI Adaptor Service&lt;/h1>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>전자정부 표준프레임워크와 UI 솔루션(Rich Internet Application) 연동에 대해 살펴 본다.
UI Adaptor를 적용하는 방식은 특정한 하나의 방법을 표준화하기 어렵다.
보통 Web Framework 과 UI 솔루션과의 연동을 하는 방법 중 가장 많이 사용하는 방식은
Controller 역할을 수행하는 Servlet 객체에서 업무 로직을 호출 전 데이터를 DTO 형태로 변화하여 업무 로직으로 넘기는 방식이다.&lt;/p>
&lt;p>전자정부 표준프레임워크에서는 Spring MVC Annotation 기반으로 개발 시 요청되는 URI 와 Controller 클래스내의 메소드를 매핑하고 있다.
따라서 메소드의 파라미터로 넘어오는 객체가 request 객체가 아닌 업무용 DTO 클래스로 넘어올 수 있도록 가이드 하는 방식을 선택했다.
(사실 @ModelAttribute 를 이용하는 것과 같다.)
하지만 프로젝트 별로 비기능 요구사항의 특성을 고려하여 적합한 구조를 정의하여 적용하는 것이 필요하다.&lt;/p></description></item><item><title>Asynchronous request processing</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/asynchronous-request-processing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/asynchronous-request-processing/</guid><description>&lt;h1 id="asynchronous-request-processing">Asynchronous request processing&lt;/h1>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>기존의 요청 처리는 하나의 요청에 대해 한 개의 쓰레드를 사용하였다. 하나의 쓰레드에서 요청-응답 과정을 모두 처리하기 때문에 요청처리 이후 응답이 오기까지 쓰레드를 대기상태로 유지하였다. 그러나 서버와의 연결을 유지한채 대기상태로 있는 것이 아니라 서버와의 처리를 계속 이어가게 해주기 위해서는 이러한 기존의 처리에 한계가 있었다.&lt;/p>
&lt;p>Servlet 3.0에서 제공하는 비동기 요청 처리는 쓰레드가 대기상태로 있는 것이 아니라 요청을 처리하는 Servlet 쓰레드가 요청후 바로 반환되고 내부의 다른 쓰레드가 이를 처리했다가 처리완료 후 응답처리 리소스가 가용할 때 Servlet쓰레드가 응답처리를 계속 이어가게 해 주는 것이다.&lt;/p></description></item><item><title>jQuery 가이드</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/jquery-ajax/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/jquery-ajax/</guid><description>&lt;h1 id="jquery-가이드">jQuery 가이드&lt;/h1>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>jQuery는 브라우저 호환성이 있는 다양한 기능을 제공하는 자바스크립트 라이브러리이다. jQuery에서 제공하는 오픈 라이브러리들을 통해 java script로 ajax, event, 다양한 ui 기능 등을 구현할 수 있으며 위키가이드에서는 jQuery의 기본적인 몇가지 기능(ajax, callback함수, post호출 등)에 대하여 살펴본다.&lt;/p>
&lt;p>자세한 내용은 &lt;a href="https://jquery.com/">jQuery 사이트&lt;/a>를 살펴보도록 한다.&lt;/p>
&lt;p>jQuery ajax의 다양한 기능들 중 기본Ajax기능과 응용을 통한 콤보박스, Select박스의 간단한 화면처리에 대하여 가이드한다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>jQuery ajax 기본기능&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://eGovFramework.github.io/egovframe-docs/egovframe-docs/egovframe-runtime/presentation-layer/jquery-ajax/#jqueryajax">jQuery.ajax()&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://eGovFramework.github.io/egovframe-docs/egovframe-docs/egovframe-runtime/presentation-layer/jquery-ajax/#jqueryget">jQuery.get()&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://eGovFramework.github.io/egovframe-docs/egovframe-docs/egovframe-runtime/presentation-layer/jquery-ajax/#jquerypost">jQuery.post()&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>jQuery ajax 응용&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://eGovFramework.github.io/egovframe-docs/egovframe-docs/egovframe-runtime/presentation-layer/jquery-ajax/#select-box">Select box&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://eGovFramework.github.io/egovframe-docs/egovframe-docs/egovframe-runtime/presentation-layer/jquery-ajax/#tabs">Tabs&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="설정">설정&lt;/h2>
&lt;p>jQuery를 이용하기 위해서는 jQuery java script를 추가해주어야 한다. 추가하는 방법은 jquery url을 직접 명시하는 경우, 프로젝트에 jquery java script를 직접 추가하여 참조하는 경우가 있다.&lt;/p></description></item><item><title>WebSocket</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/websocket/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/websocket/</guid><description>&lt;h1 id="websocket">WebSocket&lt;/h1>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>WebSocket 은 HTTP 환경에서 소켓 통신을 지원하기 위한 Spring 기술이다. Spring 은 기본적으로 WebSocket sub-protocol 로 STOMP 를 사용한다.&lt;/p>
&lt;p>(RFC6455는 웹 어플리케이션을 위한 새 기능으로 WebSocket protocol을 정의한다. 서버와 클라이언트간 양방향 통신(full-duplex)을 지원하는데, 이것은 웹을 좀 더 인터랙티브하게 만들기 위해 사용하였던 java applet, XMLHttpRequest, Flash, ActiveX 등의 기술을 대체하기 위한 중요한 기능이 될 수 있다.)&lt;/p>
&lt;p>HTTP 는 초기 handshake (protocol upgrade or switch 요청이고 서버가 동의하는 경우 101 응답을 내려 줌)를 위해서만 사용되며, handshake 가 성공하면 HTTP upgrade 요청에 기인하는 TCP 소켓이 open 된 채 서버와 클라이언트간 통신을 처리한다.&lt;/p></description></item><item><title>STOMP over WebSocket 개요 및 메시지 처리 흐름</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/websocket-stomp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/websocket-stomp/</guid><description>&lt;h1 id="stomp-over-websocket-messaging-architecture">STOMP Over WebSocket Messaging Architecture&lt;/h1>
&lt;p>&lt;a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp">http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp&lt;/a>&lt;/p>
&lt;p>WebSocket protocol 은 content 를 정의하지 않은 채 2 가지 유형 (text, binary) 의 메시지로 분류했다. content 를 정의하지 않은 대신 client 와 서버는 sub-protocol (content 를 정의하는 고수준의 protocol) 을 사용하는 것을 합의해야 할 수도 있다. sub-protocol 을 사용하는 것은 option 이지만 client 와 server 모두 메시지를 어떻게 해석해야 할지를 이해하는 것이 필요하다.&lt;/p>
&lt;h2 id="1-stomp-개요">1. STOMP 개요&lt;/h2>
&lt;p>&lt;a href="http://stomp.github.io/stomp-specification-1.2.html#Abstract">STOMP&lt;/a> 는 Ruby, Python, Perl 과 같은 스크립트 언어를 위해 고안된 단순한 메시징 프로토콜이다. 그것은 메시징 프로토콜에서 일반적으로 사용되는 패턴들의 일부를 제공한다. STOMP 는 TCP 나 WebSocket 과 같은 신뢰성있는 양방향 streaming network protocol 상에 사용될 수 있다.&lt;/p></description></item><item><title>SockJS Fallback Options</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/websocket-sockjs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/websocket-sockjs/</guid><description>&lt;h1 id="sockjs-fallback-options">SockJS Fallback Options&lt;/h1>
&lt;p>&lt;a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-fallback">http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-fallback&lt;/a>&lt;/p>
&lt;p>WebSocket 이 아직까지 모든 브라우저에서 지원되지 않거나 네트워크 프락시 제약등으로 사용할 수 없는 경우가 있다. 이에 Spring 은 fallback 옵션을 제공하는데 이는 SockJS protocol 에 기반으로 WebSocket API 를 emulate 한다.&lt;/p>
&lt;h2 id="1-sockjs-개요">1. SockJS 개요&lt;/h2>
&lt;p>SockJS 는 application 으로 하여금 WebSocket API 를 사용하는데 있다. 만약 WebSocket 사용이 불가한 경우에도 이를 fallback option 으로 제공하여 어떠한 코드 변화없이 WebSocket API 를 사용토록 한다.&lt;/p>
&lt;h3 id="sockjs-구성">SockJS 구성&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://github.com/sockjs/sockjs-protocol">SockJS protocol&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/sockjs/sockjs-client">SockJS client&lt;/a> - javascript library&lt;/li>
&lt;li>SockJS 서버 구현 - spring-websocket 모듈을 통해 제공&lt;/li>
&lt;/ul>
&lt;p>SockJS 는 여러가지 테크닉을 이용하여 다양한 브라우저 및 브라우저 버전을 지원한다. 전송 타입은 다음의 3가지로 분류된다.
&lt;strong>WebSocket, HTTP Streaming, HTTP Long Polling&lt;/strong>. 이들 각각을 살펴보려면 여기 를 참조한다.&lt;/p></description></item><item><title>UI - bootstrap</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/bootstrap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/bootstrap/</guid><description>&lt;h1 id="ui---bootstrap">UI - bootstrap&lt;/h1>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>부트스트랩(Bootstrap)은 웹디자인을 쉽게 하기 위해 트위터에서 오픈 소스로 공개한 프런트 엔드 프레임워크로, 유연한 HTML, CSS, JavaScript 템플릿과 UI컴포넌트, 인터렉션을 제공하여 손 쉽게 웹 사이트를 구축할 수 있는 시작점이 된다.&lt;/p>
&lt;p>부트스트랩의 장점은 크게 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>부트스트랩 3 이후부터 모바일 중심의 프레임워크이다&lt;/li>
&lt;li>다양한 브라우저들을 지원한다.&lt;/li>
&lt;li>반응형 웹에 최적화 되어있다. 부트스트랩은 스마트폰, 태블릿, 데스크탑에 최적화 되어 css가 조정이 된다.&lt;/li>
&lt;li>시작이 용이하다. HTML, CSS만 알고 있어도 부트스트랩의 사용이 가능하다.&lt;/li>
&lt;/ul>
&lt;p>이러한 장점들로 인해 표준프레임워크에서는 실행환경 UI로 bootstrap을 선정하였다.&lt;/p></description></item><item><title>UX/UI Controller Component</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/uxui-controller-component/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/uxui-controller-component/</guid><description>&lt;h1 id="uxui-controller-component">UX/UI Controller Component&lt;/h1>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>전자정부에서 효율적인 스마트 전자정부 기반시스템의 구축•운영을 통해 전자정부의 서비스 품질 UX 레이어는 UI/UX Controller Component, JavaScript Module App Framework, HTML5, CSS3 서비스를 제공한다. 오픈소스는 JQuery Mobile을 채택하였으며 jQuery Mobile은 html5, CSS3, javascript를 제공한다. 오픈 소스를 Customizing 하여 UI레이어의 기능을 사용 하며 내용은 아래와 같다 UI/UX Controller Component 모바일 웹 사용자 환경(UX/UI)에 대한 유연한 대응을 위해 Touch Optimized 된 필수 UI 컨트롤러 컴포넌트를 제공한다. HTML5는 모바일 웹 페이지 구성 시 사용 할 수 있는 마크업 언어로서 모바일 특화 태그 밑 디바이스 API를 제공한다. CSS3는 모바일 기기 및 브라우저에 따라 적합한 컴포넌트가 보여지는 기능을 제공한다. 또한 JavaScript Module App Framework UX/UI controller component의 효율성을 보장하는 javascript 밑 Json 구조를 제공한다.&lt;/p></description></item><item><title>HTML5 CSS3.0 JavaScript Module App Framework 기본 활용</title><link>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/html5-css3.0-javascript-module-app-framework-basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eGovFramework.github.io/egovframe-docs/egovframe-runtime/presentation-layer/html5-css3.0-javascript-module-app-framework-basic/</guid><description>&lt;h1 id="html5-css30-javascript-module-app-framework-기본-활용">HTML5 CSS3.0 JavaScript Module App Framework 기본 활용&lt;/h1>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>전자정부에서 효율적인 스마트 전자정부 기반 시스템의 구축•운영을 위해 전자정부의 서비스 품질 UX 레이어로 &lt;strong>UI/UX Controller Component&lt;/strong>, &lt;strong>HTML5&lt;/strong>, &lt;strong>CSS3&lt;/strong>, &lt;strong>JavaScript Module App Framework&lt;/strong> 서비스를 제공한다.
오픈소스는 JQuery Mobile을 채택하였으며 jQuery Mobile은 html5, CSS3, javascript를 제공한다. 이를 Customizing 하여 UI 레이어의 기능을 사용하며 내용은 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>UI/UX Controller Component&lt;/strong> : 모바일 웹 사용자 환경(UX/UI)에 대한 유연한 대응을 위해 Touch Optimized 된 필수 UI 컨트롤러 컴포넌트를 제공한다.&lt;/li>
&lt;li>&lt;strong>HTML5&lt;/strong> : 모바일 웹 페이지 구성 시 사용할 수 있는 마크업 언어로서 모바일 특화 태그 및 디바이스 API를 제공한다.&lt;/li>
&lt;li>&lt;strong>CSS3&lt;/strong> : 모바일 기기 및 브라우저에 따라 적합한 컴포넌트가 보이게 하는 기능을 제공한다.&lt;/li>
&lt;li>&lt;strong>JavaScript Module App Framework&lt;/strong> : UX/UI controller component의 효율성을 보장하는 javascript 및 Json 구조를 제공한다.&lt;/li>
&lt;/ul>
&lt;h2 id="설명">설명&lt;/h2>
&lt;h3 id="기본-활용-구조">기본 활용 구조&lt;/h3>
&lt;p>전자정부 모바일 표준프레임워크 실행환경은 기존 전자정부 표준프레임워크의 디렉터리 구조 및 표준을 준수하고 있으며, 모바일 웹 개발에 편의를 제공하기 위해 하위 디렉터리 구조를 다음과 같이 구성하고 있다.&lt;/p></description></item></channel></rss>